{
  "name": "wait.for",
  "version": "0.6.3",
  "description": "Sequential programming for node.js, end of callback hell",
  "author": {
    "name": "Lucio Tato",
    "email": "luciotato@gmail.com",
    "url": "http://github.com/luciotato"
  },
  "keywords": [
    "fiber",
    "fibers",
    "coroutine",
    "thread",
    "sync",
    "async",
    "parallel",
    "worker",
    "future",
    "promise",
    "wait",
    "Wait.for",
    "callback hell",
    "pyramid of doom"
  ],
  "homepage": "http://github.com/luciotato/waitfor",
  "license": "Creative Commons, MIT",
  "bugs": {
    "url": "http://github.com/luciotato/waitfor/issues"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/luciotato/waitfor.git"
  },
  "main": "waitfor.js",
  "engines": {
    "node": ">=0.5.2"
  },
  "dependencies": {
    "fibers": ">=1.0.1"
  },
  "scripts": {
    "test": "node tests"
  },
  "readme": "Wait.for\n=======\nSequential programming for node.js, end of callback hell.\n\nSimple, straightforward abstraction over [Fibers](https://github.com/laverdet/node-fibers).\n\nBy using **wait.for**, you can call any nodejs standard async function in sequential/Sync mode, waiting for result data, \nwithout blocking node's event loop (thanks to fibers)\n\nA nodejs standard async function is a function in which the last parameter is a callback: function(err,data)\n\nAdvantages:\n* Avoid callback hell / pyramid of doom\n* Simpler, sequential programming when required, without blocking node's event loop (thanks to fibers)\n* Simpler, try-catch exception programming. (default callback handler is: if (err) throw err; else return data)\n* You can also launch multiple parallel non-concurrent fibers.\n* No multi-threaded debugging nightmares, only one fiber running at a given time (thanks to fibers)\n* Can use any node-standard async function with callback(err,data) as last parameter.\n* Plays along with node programming style. Write your async functions with callback(err,data), but use them in sequential/SYNC mode when required.\n* Plays along with node cluster. You design for one thread/processor, then scale with cluster on multicores.\n\n--- NEWS ---\n-\nI've developed ***a version based on JavaScript upcoming ES6-Harmony generators***. It's not based on node-fibers.\n***Surprisingly***, ES6 based implementation of *wait.for(asyncFn)* is almost a no-op, you can even completely omit it.\n*Warning: Bleeding edge*. Check [Wait.for-ES6] (https://github.com/luciotato/waitfor-ES6/blob/master/README.md#the-funny-thing-is) \n\n\nInstall: \n-\n        npm install wait.for\n\n\nProper Use:\n-\nWait.for proper usage is to launch a fiber to attend a request. Ideally here:\n\n```javascript\nvar server = http.createServer(\n  function(req, res){\n    console.log('req!');\n    wait.launchFiber(handler,req,res); //handle in a fiber\n    // keep node spinning\n  }).listen(8000);\n```\n\nthen,at *function handler(req,res)* and every function you call from there, you'll be able to use wait.for(ayncFn...\n\nExamples:\n-\n\nDNS testing, *using pure node.js* (a little of callback hell):\n```javascript\nvar dns = require(\"dns\");\n    \nfunction test(){ \n\tdns.resolve4(\"google.com\", function(err, addresses) {\n\t\tif (err) throw err;\n\t\tfor (var i = 0; i < addresses.length; i++) {\n\t\t\tvar a = addresses[i];\n\t\t\tdns.reverse(a, function (err, data) {\n\t\t\t\tif (err) throw err;\n\t\t\t\tconsole.log(\"reverse for \" + a + \": \" + JSON.stringify(data));\n\t\t\t});\n\t\t};\n\t});\n}\n\ntest();\n```\n\n***THE SAME CODE***, using **wait.for** (sequential):\n```javascript\nvar dns = require(\"dns\"), wait=require('wait.for');\n\nfunction test(){\n\tvar addresses = wait.for(dns.resolve4,\"google.com\");\n\tfor (var i = 0; i < addresses.length; i++) {\n\t\tvar a = addresses[i];\n\t\tconsole.log(\"reverse for \" + a + \": \" + JSON.stringify(wait.for(dns.reverse,a)));\n\t}\n}\n\nwait.launchFiber(test); \n```\n\nDatabase example (pseudocode)\n--\n*using pure node.js* (a callback hell):\n```javascript\nvar db = require(\"some-db-abstraction\");\n\nfunction handleWithdrawal(req,res){  \n\ttry {\n\t\tvar amount=req.param(\"amount\");\n\t\tdb.select(\"* from sessions where session_id=?\",req.param(\"session_id\"),function(err,sessiondata) {\n\t\t\tif (err) throw err;\n\t\t\tdb.select(\"* from accounts where user_id=?\",sessiondata.user_ID),function(err,accountdata) {\n\t\t\t\tif (err) throw err;\n\t\t\t\t\tif (accountdata.balance < amount) throw new Error('insufficient funds');\n\t\t\t\t\tdb.execute(\"withdrawal(?,?)\",accountdata.ID,req.param(\"amount\"), function(err,data) {\n\t\t\t\t\t\tif (err) throw err;\n\t\t\t\t\t\tres.write(\"withdrawal OK, amount: \"+ req.param(\"amount\"));\n\t\t\t\t\t\tdb.select(\"balance from accounts where account_id=?\", accountdata.ID,function(err,balance) {\n\t\t\t\t\t\t\tif (err) throw err;\n\t\t\t\t\t\t\tres.end(\"your current balance is \"  + balance.amount);\n\t\t\t\t\t\t});\n    \t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tcatch(err) {\n\t\t\tres.end(\"Withdrawal error: \"  + err.message);\n\t}\n}\n```\nNote: The above code, although it looks like it will catch the exceptions, **it will not**. \nCatching exceptions with callback hell adds a lot of pain, and i'm not sure if you will have the 'res' parameter \nto respond to the user. If somebody like to fix this example... be my guest.\n\n\n***THE SAME CODE***, using **wait.for** (sequential logic - sequential programming):\n```javascript\nvar db = require(\"some-db-abstraction\"), wait=require('wait.for');\n\nfunction handleWithdrawal(req,res){  \n\ttry {\n\t\tvar amount=req.param(\"amount\");\n\t\tsessiondata = wait.forMethod(db,\"select\",\"* from session where session_id=?\",req.param(\"session_id\"));\n\t\taccountdata = wait.forMethod(db,\"select\",\"* from accounts where user_id=?\",sessiondata.user_ID);\n\t\tif (accountdata.balance < amount) throw new Error('insufficient funds');\n\t\twait.forMethod(db,\"execute\",\"withdrawal(?,?)\",accountdata.ID,req.param(\"amount\"));\n\t\tres.write(\"withdrawal OK, amount: \"+ req.param(\"amount\"));\n\t\tbalance = wait.forMethod(db,\"select\",\"balance from accounts where account_id=?\", accountdata.ID);\n\t\tres.end(\"your current balance is \"  + balance.amount);\n\t\t}\n\tcatch(err) {\n\t\tres.end(\"Withdrawal error: \"  + err.message);\n}  \n```\n\n\nNote: Exceptions will be catched as expected.\ndb methods (db.select, db.execute) will be called with this=db\n\n\nWhat if... Fibers and WaitFor were part of node core?\n-\nthen you can deprecate almost half the functions at: http://nodejs.org/api/fs.html\n(clue: the *Sync* versions)\n\nExample:\n--\n\npure node.js:\n```javascript\nvar fs = require(\"fs\");\n\nfs.readFile('/etc/passwd', function (err, data) {\n\tif (err) throw err;\n\tconsole.log(data);\n});\n```\n\n\nusing **wait.for**:\n```javascript\nvar fs = require(\"fs\"), wait=require('wait.for');\n\nconsole.log(wait.for(fs.readFile,'/etc/passwd'));\n```\n\n\n\n(see tests.js for more examples)\n\nUsage: \n-\n```javascript\nvar wait=require('wait.for');\n\n// launch a new fiber\nwait.launchFiber(my_seq_function, arg,arg,...)\n\n// fiber\nfunction my_seq_function(arg,arg...){\n    // call async_function(arg1), wait for result, return data\n    var myObj = wait.for(async_function, arg1); \n    // call myObj.querydata(arg1,arg2), wait for result, return data\n    var myObjData = wait.forMethod(myObj,'queryData', arg1, arg2);\n    console.log(myObjData.toString());\n}\n```\n\nRoadmap\n--\n\n * Parallel execution, launch one fiber for each array item, waits until all fibers complete execution.\n   * **function wait.parallel.map(arr,fn)** return transformed array;\n   * **function wait.parallel.filter(arr,fn)** return filtered array;\n   * Status: working prototypes in [paralell-tests.js](http://github.com/luciotato/waitfor/blob/master/paralell-tests.js)\n",
  "readmeFilename": "README.md",
  "_id": "wait.for@0.6.3",
  "_from": "wait.for@"
}
